# «Servlet Containers»

## CRUD

### Легенда

Существует практически полноценный In-Memory CRUD-сервер (Create Read Update Delete) на базе сервлетов, у которого есть главный класс для взаимодействия Post:
```java
public class Post {
    private long id;
    private String content;
}
```

### Задача

1. Создать простой CRUD-сервер на http://localhost:8080/api/posts.
1. Реализовать репозиторий с учётом того, что методы репозитория могут вызываться конкурентно, т. е. в разных потоках.

Как должен работать `save`:

1. Если от клиента приходит пост с id=0, значит, это создание нового поста. Вы сохраняете его в списке и присваиваете ему новый id. Достаточно хранить счётчик с целым числом и увеличивать на 1 при создании каждого нового поста.
1. Если от клиента приходит пост с id !=0, значит, это сохранение (обновление) существующего поста. Вы ищете его в списке по id и обновляете. Продумайте самостоятельно, что вы будете делать, если поста с таким id не оказалось: здесь могут быть разные стратегии.

## DI

### Легенда

Возникает вопрос, почему бы не использовать использовать Spring для связывания зависимостей в приложении с сервлетами и не заменить указанный ниже код на DI со Spring:
```java
@Override
public void init() {
    final var repository = new PostRepository();
    final var service = new PostService(repository);
    controller = new PostController(service);
}
```

### Задача

Замените код в методе `init` на DI со Spring с использованием методов конфигурирования бинов:

1. Annotation Config — ветка `feature/di-annotation`.
1. Java Config — ветка `feature/di-java`.

Обратите внимание, что вся функциональность (CRUD), реализованная до этого, должна по-прежнему работать.
